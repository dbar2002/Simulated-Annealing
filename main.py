'''
AUTHOR: Joshua Cervantes, Duncan Barnes
DATE: Feb 13, 2024

COURSE: CSC - Intelligent Systems
California Baptist University
College of Engineering
Computer Science & Data Science Department

DESCRIPTION: This python file is a shell for simulated annealing for the
n-queens problem. Students should fill in the algorithmic details to
complete the exercise.
'''

"""Imports"""
from random import randint
import math
import random

'''
This function performs simulated annealing. Specifically, it is tailored for
the n-queens problem...we'll be solving the 8-queens problem. We use a list
to represent the state. Each list element represents a separate column on the
board. Each number represents the row in that particular column that has a 
queen. For instance, [1,2,3,4,5,6,7,8] represents the board with a diagonal
of queens from the bottom left corner to the top right corner.
'''
n = 8  # for 8-queens problem


def SimulatedAnnealing():
    initialBoardArray = GenerateRandomBoardState() # s <- s0
    PrintBoard(initialBoardArray)
    cost = Fitness(initialBoardArray, True) # e <- E(s)
    print
    "The initial solution has " + str(cost) + " pairs of queens in attacking position."


# Uncomment to see what this method does
# print GenerateRandomNeighborState(initialBoardArray)

# Write simulated annealing code here. This is the only place you will need to write code.
    sBest = initialBoardArray
    eBest = cost
    K = 0
    kMax = 1000000
    eGoal = 0
    tMax = 1
    while (K < kMax and cost > eGoal):
        T = tMax * (1 - K / kMax)
        sNew = GenerateRandomNeighborState(initialBoardArray)
        eNew = Fitness(sNew, False)
        deltaE = eNew - cost
        if eNew < cost:
            initialBoardArray = sNew
            cost = eNew
            if cost < eBest:
                sBest = sNew
                eBest = eNew
        else:
            if random.uniform(0, 1) < math.exp(deltaE / T):
                initialBoardArray = sNew
                cost = eNew
        K = K + 1
    print sBest



'''
This function takes as parameters a list representing the state and a boolean
which tells whether to print the attacking pair details or not.

This function returns the number of pairs of queens that are in attacking
position with each other. The maximum number of pairs is 28, which is the worst
possible arrangement. If the function returns 0 pairs, then we have found a goal
state.

NOTE: Pass in verbose == true to print all attacking pairs
'''


def Fitness(boardArray, verbose):
    # Measure the number of pairs that are in conflict with each other
    attackingQueenPairs = 0
    for i in range(0, len(boardArray) - 1):
        for j in range(i + 1, len(boardArray)):
            if (boardArray[i] == boardArray[j]):  # Check horizontal
                attackingQueenPairs = attackingQueenPairs + 1
                if verbose: print
                "Attacking Horizontal: (" + str(i + 1) + ", " + str(boardArray[i]) + ")<-->(" + str(j + 1) + ", " + str(
                    boardArray[j]) + ")"
            elif (abs(i - j) == abs(boardArray[i] - boardArray[j])):  # Check diagonal
                attackingQueenPairs = attackingQueenPairs + 1
                if verbose: print
                "Attacking Diagonal: (" + str(i + 1) + ", " + str(boardArray[i]) + ")<-->(" + str(j + 1) + ", " + str(
                    boardArray[j]) + ")"
                # NOTE: By nature of the state representation, we will never have attacking
                # queens in the same column.

    return attackingQueenPairs


"""
Simply prints the board in an easy-to-read format
"""


def PrintBoard(boardArray):
    boardGrid = [["-" for x in range(n)] for x in range(n)]

    # Set grid to array queen positions
    for i in range(0, len(boardArray)):
        boardGrid[n - boardArray[i]][i - n] = "Q"

    # Print the board
    for i in range(0, len(boardArray)):
        print
        boardGrid[i]


"""
Generates a random board state
"""


def GenerateRandomBoardState():
    boardArray = []
    for i in range(0, n):
        boardArray.append(randint(1, n))
    return boardArray


"""
Generates a random neighbor state. Neighbor state generated by picking
a random column and then changes row to random value.
"""


def GenerateRandomNeighborState(state):
    import copy
    neighbor = copy.copy(state)
    col = randint(0, n - 1)  # 3
    newRow = randint(1, n)  # 7
    curRow = state[col]  # 4

    # Generate a new row value
    while newRow == curRow:
        newRow = randint(1, n)
    neighbor[col] = newRow

    return neighbor


'''CODE TO RUN'''
SimulatedAnnealing()

