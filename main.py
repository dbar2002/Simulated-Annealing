'''
AUTHOR: Joshua Cervantes, Duncan Barnes
DATE: Feb 13, 2024

COURSE: CSC - Intelligent Systems
California Baptist University
College of Engineering
Computer Science & Data Science Department

DESCRIPTION: This python file is a shell for simulated annealing for the
n-queens problem. Students should fill in the algorithmic details to
complete the exercise.
'''

"""Imports"""
from random import randint
import math
import random

'''
This function performs simulated annealing. Specifically, it is tailored for
the n-queens problem...we'll be solving the 8-queens problem. We use a list
to represent the state. Each list element represents a separate column on the
board. Each number represents the row in that particular column that has a 
queen. For instance, [1,2,3,4,5,6,7,8] represents the board with a diagonal
of queens from the bottom left corner to the top right corner.
'''
n = 8  # for 8-queens problem


def SimulatedAnnealing():
    initialBoardArray = GenerateRandomBoardState() # s <- s0
    PrintBoard(initialBoardArray)
    cost = Fitness(initialBoardArray, True) # e <- E(s)
    print
    "The initial solution has " + str(cost) + " pairs of queens in attacking position."


# Uncomment to see what this method does
# print GenerateRandomNeighborState(initialBoardArray)

# Write simulated annealing code here. This is the only place you will need to write code.
# Simulated annealing code starts here.
    temperature = 1000  # Initial temperature
    cooling_rate = 0.005  # Cooling rate

    current_solution = initialBoardArray  # Start with initial solution
    current_energy = Fitness(current_solution, False)  # Calculate energy of current solution

    iterations = 0
    while temperature > 1 and iterations < 100000:
        neighbor_solution = GenerateRandomNeighborState(current_solution)  # Generate neighbor solution
        neighbor_energy = Fitness(neighbor_solution, False)  # Calculate energy of neighbor solution

        energy_difference = neighbor_energy - current_energy  # Calculate energy difference

        # Accept or reject the neighbor solution
        if energy_difference < 0 or random.random() < math.exp(-energy_difference / temperature):
            current_solution = neighbor_solution
            current_energy = neighbor_energy

        temperature *= 1 - cooling_rate  # Cool down temperature
        iterations += 1

    PrintBoard(current_solution)  # Print final solution
    print("The final solution has " + str(current_energy) + " pairs of queens in attacking position.")
    print("Total iterations:", iterations)



'''
This function takes as parameters a list representing the state and a boolean
which tells whether to print the attacking pair details or not.

This function returns the number of pairs of queens that are in attacking
position with each other. The maximum number of pairs is 28, which is the worst
possible arrangement. If the function returns 0 pairs, then we have found a goal
state.

NOTE: Pass in verbose == true to print all attacking pairs
'''


def Fitness(boardArray, verbose):
    # Measure the number of pairs that are in conflict with each other
    attackingQueenPairs = 0
    for i in range(0, len(boardArray) - 1):
        for j in range(i + 1, len(boardArray)):
            if (boardArray[i] == boardArray[j]):  # Check horizontal
                attackingQueenPairs = attackingQueenPairs + 1
                if verbose: print
                "Attacking Horizontal: (" + str(i + 1) + ", " + str(boardArray[i]) + ")<-->(" + str(j + 1) + ", " + str(
                    boardArray[j]) + ")"
            elif (abs(i - j) == abs(boardArray[i] - boardArray[j])):  # Check diagonal
                attackingQueenPairs = attackingQueenPairs + 1
                if verbose: print
                "Attacking Diagonal: (" + str(i + 1) + ", " + str(boardArray[i]) + ")<-->(" + str(j + 1) + ", " + str(
                    boardArray[j]) + ")"
                # NOTE: By nature of the state representation, we will never have attacking
                # queens in the same column.

    return attackingQueenPairs


"""
Simply prints the board in an easy-to-read format
"""


def PrintBoard(boardArray):
    boardGrid = [["-" for x in range(n)] for x in range(n)]

    # Set grid to array queen positions
    for i in range(0, len(boardArray)):
        boardGrid[n - boardArray[i]][i - n] = "Q"

    # Print the board
    for i in range(0, len(boardArray)):
        print
        boardGrid[i]


"""
Generates a random board state
"""


def GenerateRandomBoardState():
    boardArray = []
    for i in range(0, n):
        boardArray.append(randint(1, n))
    return boardArray


"""
Generates a random neighbor state. Neighbor state generated by picking
a random column and then changes row to random value.
"""


def GenerateRandomNeighborState(state):
    import copy
    neighbor = copy.copy(state)
    col = randint(0, n - 1)  # 3
    newRow = randint(1, n)  # 7
    curRow = state[col]  # 4

    # Generate a new row value
    while newRow == curRow:
        newRow = randint(1, n)
    neighbor[col] = newRow

    return neighbor


'''CODE TO RUN'''
SimulatedAnnealing()

